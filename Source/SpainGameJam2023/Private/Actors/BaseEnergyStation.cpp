// All code generated by Aleix Rius for the Indie Spain Dev 2023. The code is delivered as is.


#include "Actors/BaseEnergyStation.h"
#include "Components/EnergyPipeBuilder.h"
#include "Components/BuildingEnergyNode.h"
#include "GameInstanceManagers.h"
#include "Energy/EnergyManager.h"
#include "Kismet/GameplayStatics.h"


// Sets default values
ABaseEnergyStation::ABaseEnergyStation()
{
	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = false;
	energyNode = CreateDefaultSubobject<UBuildingEnergyNode>("Energy Node");

	energyBuilder = CreateDefaultSubobject<UEnergyPipeBuilder>("Energy builder");

}

// Called when the game starts or when spawned
void ABaseEnergyStation::BeginPlay()
{
	Super::BeginPlay();
	RegisterToManager();
	energyNode->SetEnergyIncome(energy);

	TArray<AActor*> FoundActors;
	UGameplayStatics::GetAllActorsWithTag(GetWorld(), UBuildingEnergyNode::ENERGY_TAG, FoundActors);
	const float threshold = range * range;
	for (auto& actor : FoundActors)
	{
		if (Cast< ABaseEnergyStation>(actor)) continue;
		auto node = actor->GetComponentByClass<UBuildingEnergyNode>();
		if (!node)continue; // No energy component to connect
		if (node->GetInPipe() != nullptr)continue; // Is already connected

		auto distance = static_cast<float>(FVector::DistSquared(GetActorLocation(), actor->GetActorLocation()));
		if (distance < threshold)
		{
			connectedComponents.Add(node);
		}
	}

	init = true;
	RebuildPipeGraph();
}

void ABaseEnergyStation::RebuildPipeGraph()
{
	if (!init)return;
	energyBuilder->RebuildPipeGraphFromNode(energyNode, connectedComponents);
}

float ABaseEnergyStation::GetRange() const
{
	return range;
}

void ABaseEnergyStation::Connect(UBuildingEnergyNode* node)
{
	if (!node)return;
	if (!init)return;
	if (Cast< ABaseEnergyStation>(node->GetOwner())) return;
	connectedComponents.AddUnique(node);
}

void ABaseEnergyStation::Disconnect(UBuildingEnergyNode* node)
{
	if (!init)return;
	connectedComponents.Remove(node);
}

void ABaseEnergyStation::DealDamage_Implementation(float ammount) const
{
}

void ABaseEnergyStation::ReceiveDamage_Implementation(float ammount)
{
	combatStats.health -= ammount;
	if (combatStats.health <= 0)
	{
		Destroy();
	}
}

void ABaseEnergyStation::GetCombatStats_Implementation(FCombatStats& out) const
{
}

void ABaseEnergyStation::SetCombatStats_Implementation(const FCombatStats& stats)
{
}

void ABaseEnergyStation::RegisterToManager()
{
	if(!GetWorld()) return;
	auto gInstance = Cast<UGameInstanceManagers>(GetGameInstance());
	if (gInstance)
	{
		if (auto manager = gInstance->GetEnergyManager())
		{
			manager->RegisterEnergyStation(this);
		}
	}
}

void ABaseEnergyStation::UnregisterToManager()
{
	if (!GetWorld()) return;
	auto gInstance = Cast<UGameInstanceManagers>(GetGameInstance());
	if (gInstance)
	{
		if (auto manager = gInstance->GetEnergyManager())
		{
			manager->UnregisterEnergyStation(this);
		}
	}

}

void ABaseEnergyStation::BeginDestroy()
{
	if (energyBuilder && energyNode)
	{
		energyBuilder->ClearGraphFrom(energyNode);
	}
	UnregisterToManager();
	Super::BeginDestroy();
}


