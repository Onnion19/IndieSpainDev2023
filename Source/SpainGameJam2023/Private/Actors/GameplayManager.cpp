// All code generated by Aleix Rius for the Indie Spain Dev 2023. The code is delivered as is.


#include "Actors/GameplayManager.h"
#include "Utils/EnemySpawner.h"
#include "GameInstanceManagers.h"
#include "Utils/EnemyDataAsset.h"
#include "Actors/BaseEnemy.h"
#include "Actors/BaseTurret.h"
#include "Kismet/GameplayStatics.h"
#include "Actors/BaseBeaconActor.h"
#include "Actors/BaseEnergyStation.h"
#include <algorithm>

// Sets default values
AGameplayManager::AGameplayManager()
{
	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = false;
	gameStatus = EGameStatus::PLAYING;
}

void AGameplayManager::PostInitializeComponents()
{
	Super::PostInitializeComponents();
	auto gameInstance = Cast<UGameInstanceManagers>(GetGameInstance());
	gameInstance->SetGamePlayManager(this);
}

// Called when the game starts or when spawned
void AGameplayManager::BeginPlay()
{
	Super::BeginPlay();

	if (!spawner)
	{
		SearchSpawner();
	}
	ensureMsgf(spawner, TEXT("Gameplay maanger spawner reference is missing"));
}

EGameStatus AGameplayManager::GetGamestatus()
{
	return gameStatus;
}

void AGameplayManager::OnChangeGameStage(EGameModeStage stage)
{
	if (stage == EGameModeStage::PREPARATIONS)
	{
		StopWave();
		DisablePlayerStructures();
	}
	else if (stage == EGameModeStage::COMBAT)
	{
		EnablePlayerStructures();
	}

	OnGameModeChangeBP(stage);
}

void AGameplayManager::SpawnWave(int32 wave)
{
	if (wave >= waves.Num())
	{
		UE_LOG(LogTemp, Error, TEXT("Trying to spawn a wave with invalid index %i"), wave);
		return;
	}

	gameStatus = EGameStatus::PLAYING;
	currentWave = wave;
	spawner->SpawnNewWave(waves[currentWave]);
}

int32 AGameplayManager::GetNumWaves() const
{
	return waves.Num();
}

UEnemyDataAsset* AGameplayManager::GetCurrentWave(int32& waveIndex) const
{
	waveIndex = currentWave;
	return waves[currentWave];
}

void AGameplayManager::StopWave()
{
	if (spawner->IsSpawning())
	{
		spawner->CancelSpawn();
	}
}

void AGameplayManager::PlayerStructureCreated(AActor* structure)
{
	playerStructures.Add(structure);
}

void AGameplayManager::PlayerStructureDestroyed(AActor* structure)
{
	OnPlayerStrucureDestroyed.Broadcast(structure);

	playerStructures.Remove(structure);

	// DEFEAT
	if (playerStructures.IsEmpty())
	{
		Defeat();
	}
}

void AGameplayManager::GetPlayerStructures(TArray<AActor*>& structures) const
{
	structures = playerStructures;
}

TArray<class ABaseEnergyStation*> AGameplayManager::GetPlayerEnergyStations() const
{
	return GetPlayerStructuresByType<ABaseEnergyStation>();
}

TArray<ABaseBeaconActor*> AGameplayManager::GetPlayerBeacons() const
{
	auto beacons = GetPlayerStructuresByType<ABaseBeaconActor>();

	// remvoe non active beacons
	for (int i = beacons.Num() - 1; i > -1; i--)
	{
		if (!beacons[i]->IsActive())
		{
			beacons.RemoveAt(i);
		}
	}

	return beacons;

}

void AGameplayManager::Defeat()
{
	if (gameStatus == EGameStatus::PLAYING)
	{
		gameStatus = EGameStatus::DEFEAT;
		StopWave();
		auto instance = Cast<UGameInstanceManagers>(GetGameInstance());
		if (instance)
		{
			instance->Defeat();
		}
	}
}

void AGameplayManager::OnNewEnemySpawn(ABaseEnemy* enemy)
{
	spawnedEnemies.AddUnique(enemy);
}

void AGameplayManager::EnemyDestroyed(ABaseEnemy* enemy)
{
	if (spawnedEnemies.Remove(enemy) == 0) return;

	if (spawnedEnemies.IsEmpty() && !spawner->IsSpawning())
	{
		if (gameStatus == EGameStatus::PLAYING)
		{
			OnWaveEndBP();
			OnWaveEnd.Broadcast();

			auto gInstance = Cast<UGameInstanceManagers>(GetGameInstance());
			if (gInstance)
			{
				gInstance->ChangeGameStage(EGameModeStage::PREPARATIONS);
			}
		}
	}

}

void AGameplayManager::AddGold(int32 deltaGold)
{
	gold = std::max(0, gold + deltaGold);
	OnGoldChange.Broadcast(gold);
}

int32 AGameplayManager::GetGold() const
{
	return gold;
}

void AGameplayManager::EnablePlayerStructures()
{

	for (AActor* structure : playerStructures)
	{
		ABaseTurret* turret = Cast<ABaseTurret>(structure);
		if (turret)
		{
			turret->ActivateTurret();
			turret->SwapToMode(ETurretMode::FIRING);
			continue;
		}
	}

}

void AGameplayManager::DisablePlayerStructures()
{
	for (AActor* structure : playerStructures)
	{
		ABaseTurret* turret = Cast<ABaseTurret>(structure);
		if (turret)
		{
			turret->DeactivateTurret();
			turret->SwapToMode(ETurretMode::IDLE);
			continue;
		}
	}
}

void AGameplayManager::SearchSpawner()
{
	spawner = Cast< AEnemySpawner>(UGameplayStatics::GetActorOfClass(GetWorld(), AEnemySpawner::StaticClass()));
	if (!spawner)
	{
		UE_LOG(LogTemp, Error, TEXT("No spawner find in world"));
	}

}
