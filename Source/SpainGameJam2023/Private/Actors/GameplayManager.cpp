// All code generated by Aleix Rius for the Indie Spain Dev 2023. The code is delivered as is.


#include "Actors/GameplayManager.h"
#include "Utils/EnemySpawner.h"
#include "GameInstanceManagers.h"
#include "Utils/EnemyDataAsset.h"
#include "Actors/BaseEnemy.h"
#include "Actors/BaseTurret.h"

// Sets default values
AGameplayManager::AGameplayManager()
{
	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = false;
	gameStatus = EGameStatus::PLAYING;
}

// Called when the game starts or when spawned
void AGameplayManager::BeginPlay()
{
	Super::BeginPlay();

	auto gameInstance = Cast<UGameInstanceManagers>(GetGameInstance());
	gameInstance->SetGamePlayManager(this);

	ensureMsgf(spawner, TEXT("Gameplay maanger spawner reference is missing"));
}

EGameStatus AGameplayManager::GetGamestatus()
{
	return gameStatus;
}

void AGameplayManager::OnChangeGameStage(EGameModeStage stage)
{
	if (stage == EGameModeStage::PREPARATIONS)
	{
		StopWave();
		DisablePlayerStructures();
	}
	else if (stage == EGameModeStage::COMBAT)
	{
		EnablePlayerStructures();
	}

	OnGameModeChangeBP(stage);
}

void AGameplayManager::SpawnWave(int32 wave)
{
	if (wave >= waves.Num())
	{
		UE_LOG(LogTemp, Error, TEXT("Trying to spawn a wave with invalid index %i"), wave);
		return;
	}

	gameStatus = EGameStatus::PLAYING;
	currentWave = wave;
	spawner->SpawnNewWave(waves[currentWave]);
}

int32 AGameplayManager::GetNumWaves() const
{
	return waves.Num();
}

UEnemyDataAsset* AGameplayManager::GetCurrentWave(int32& waveIndex) const
{
	waveIndex = currentWave;
	return waves[currentWave];
}

void AGameplayManager::StopWave()
{
	if (spawner->IsSpawning())
	{
		spawner->CancelSpawn();
	}
}

void AGameplayManager::PlayerStructureCreated(AActor* structure)
{
	playerStructures.Add(structure);
}

void AGameplayManager::PlayerStructureDestroyed(AActor* structure)
{
	OnPlayerStrucureDestroyed.Broadcast(structure);

	playerStructures.Remove(structure);

	// DEFEAT
	if (playerStructures.IsEmpty())
	{
		Defeat();
	}
}

void AGameplayManager::GetPlayerStructures(TArray<AActor*>& structures) const
{
	structures = playerStructures;
}

void AGameplayManager::Defeat()
{
	if (gameStatus == EGameStatus::PLAYING)
	{
		gameStatus = EGameStatus::DEFEAT;
		StopWave();
		auto instance = Cast<UGameInstanceManagers>(GetGameInstance());
		if (instance)
		{
			instance->Defeat();
		}
	}
}

void AGameplayManager::OnNewEnemySpawn(ABaseEnemy* enemy)
{
	spawnedEnemies.AddUnique(enemy);
}

void AGameplayManager::EnemyDestroyed(ABaseEnemy* enemy)
{
	if (spawnedEnemies.Remove(enemy) == 0) return;

	if (spawnedEnemies.IsEmpty() && !spawner->IsSpawning())
	{
		if (gameStatus == EGameStatus::PLAYING)
		{
			OnWaveEndBP();
			OnWaveEnd.Broadcast();

			auto gInstance = Cast<UGameInstanceManagers>(GetGameInstance());
			if (gInstance)
			{
				gInstance->ChangeGameStage(EGameModeStage::PREPARATIONS);
			}
		}
	}

}

void AGameplayManager::EnablePlayerStructures()
{

	for (AActor* structure : playerStructures)
	{
		ABaseTurret* turret = Cast<ABaseTurret>(structure);
		if (turret)
		{
			turret->ActivateTurret();
			turret->SwapToMode(ETurretMode::FIRING);
			continue;
		}
	}

}

void AGameplayManager::DisablePlayerStructures()
{
	for (AActor* structure : playerStructures)
	{
		ABaseTurret* turret = Cast<ABaseTurret>(structure);
		if (turret)
		{
			turret->DeactivateTurret();
			turret->SwapToMode(ETurretMode::IDLE);
			continue;
		}
	}
}
