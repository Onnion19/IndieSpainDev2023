// All code generated by Aleix Rius for the Indie Spain Dev 2023. The code is delivered as is.


#include "Components/BuildingEnergyNode.h"
#include "Actors/BaseEnergyPipe.h"
#include "Actors/BaseEnergyStation.h"
#include "GameInstanceManagers.h"
#include "Energy/EnergyManager.h"
#include "Actors/BaseEnergyStation.h"
#include <limits>

// Sets default values for this component's properties
UBuildingEnergyNode::UBuildingEnergyNode()
{
	// Set this component to be initialized when the game starts, and to be ticked every frame.  You can turn these features
	// off to improve performance if you don't need them.
	PrimaryComponentTick.bCanEverTick = false;

	auto owner = GetOwner();
	if (owner)
	{
		owner->Tags.AddUnique(ENERGY_TAG);
	}
	// ...
}

void UBuildingEnergyNode::BeginPlay()
{
	Super::BeginPlay();

	if (auto station = FindClosestStation())
	{
		ConnectToStation(station);
	}
}

void UBuildingEnergyNode::OnComponentDestroyed(bool bDestroyingHierarchy)
{
	if (inPipe)
	{
		if (auto station = Cast<ABaseEnergyStation>(inPipe->GetOwner()))
		{
			station->Disconnect(this);
			station->RebuildPipeGraph();
		}
	}

	Super::OnComponentDestroyed(bDestroyingHierarchy);
}

void UBuildingEnergyNode::NewOutPipe(ABaseEnergyPipe* pipe)
{
	if (pipe == inPipe)
	{
		UE_LOG(LogTemp, Warning, TEXT("Trying to make a cyclic pipe circuit"));
		return;
	}

	outPipes.AddUnique(pipe);
}

void UBuildingEnergyNode::NewInPipe(ABaseEnergyPipe* pipe)
{

	inPipe = pipe;
}

void UBuildingEnergyNode::RemovePipe(ABaseEnergyPipe* pipe)
{
	if (!pipe)return;
	outPipes.Remove(pipe);

	if (inPipe == pipe)
	{
		inPipe = nullptr;
	}
}

void UBuildingEnergyNode::GetOutPipes(TArray< ABaseEnergyPipe*>& pipes) const
{
	pipes = outPipes;
}

ABaseEnergyPipe* UBuildingEnergyNode::GetInPipe() const
{
	return inPipe;
}

void UBuildingEnergyNode::SetEnergyIncome(float energyLevel)
{
	bool hadEnergy = GetNodeEnergy() >= 0;
	incomingEnergy = energyLevel;
	bool hasEnergyNow = GetNodeEnergy() >= 0;
	if (hadEnergy != hasEnergyNow)
	{
		if (hasEnergyNow) OnReceiveEnergy.Broadcast();
		else OnStopReceiveEnergy.Broadcast();
	}
}

float UBuildingEnergyNode::GetEnergyConsumption() const
{
	return energyConsumption;
}

float UBuildingEnergyNode::GetNodeEnergy() const
{
	return incomingEnergy - energyConsumption;
}

ABaseEnergyStation* UBuildingEnergyNode::FindClosestStation()
{
	auto gInstance = Cast<UGameInstanceManagers>(GetOwner()->GetGameInstance());
	if (!gInstance) return nullptr;
	auto manager = gInstance->GetEnergyManager();
	if (!manager)return nullptr;
	auto stations = manager->GetStationList();


	const FVector location = GetOwner()->GetActorLocation();
	float min = std::numeric_limits<float>::max();
	ABaseEnergyStation* bestStation = nullptr;
	for (auto station : stations)
	{
		const FVector stationLocation = station->GetActorLocation();
		const auto range = station->GetRange() * station->GetRange();
		const auto distance = FVector::DistSquared(location, stationLocation);
		if (distance < range && distance < min)
		{
			min = distance;
			bestStation = station;
		}
	}

	return bestStation;

}

void UBuildingEnergyNode::ConnectToStation(ABaseEnergyStation* station)
{
	if (!station)return;

	station->Connect(this);
	station->RebuildPipeGraph();
}