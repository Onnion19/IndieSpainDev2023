// All code generated by Aleix Rius for the Indie Spain Dev 2023. The code is delivered as is.


#include "Components/EnergyPipeBuilder.h"
#include "Actors/BaseEnergyPipe.h"
#include "Components/BuildingEnergyNode.h"
#include "Actors/BaseEnergyStation.h"
#include <limits>

// Sets default values for this component's properties
UEnergyPipeBuilder::UEnergyPipeBuilder()
{
	// Set this component to be initialized when the game starts, and to be ticked every frame.  You can turn these features
	// off to improve performance if you don't need them.
	PrimaryComponentTick.bCanEverTick = false;

	// ...
}

void UEnergyPipeBuilder::RebuildPipeGraphFromNode(UBuildingEnergyNode* node, TArray<UBuildingEnergyNode*> nodesToConnect)
{
	ClearGraphFrom(node);
	BuildGraphFromNode(node, nodesToConnect);
}

void UEnergyPipeBuilder::ClearGraphFrom(UBuildingEnergyNode* node)
{
	if (!node) return;

	TArray<ABaseEnergyPipe*> node_pipes;
	node->GetOutPipes(node_pipes);
	for (auto& pipe : node_pipes)
	{
		ClearGraphFrom(pipe);
		unusedPipes.AddUnique(pipe);
	}

}

std::tuple<class UBuildingEnergyNode*, class UBuildingEnergyNode*> UEnergyPipeBuilder::FindNextNodeToConnect(const TArray<UBuildingEnergyNode*>& connectedNodes, const TArray<UBuildingEnergyNode*>& nodesToConnect)
{
	UBuildingEnergyNode* root = nullptr;
	UBuildingEnergyNode* dest = nullptr;

	float bestDistance = std::numeric_limits<float>::max();

	for (auto& cn : connectedNodes)
	{

		auto [node, distance] = FindClosestNodeFrom(cn, nodesToConnect);

		if (distance < bestDistance)
		{
			root = cn;
			dest = node;
			bestDistance = distance;
		}
	}

	return { root, dest };
}

void UEnergyPipeBuilder::BuildGraphFromNode(UBuildingEnergyNode* node, TArray<UBuildingEnergyNode*>& nodesToConnect)
{
	TArray<UBuildingEnergyNode*> connectedNodes;
	connectedNodes.Add(node);
	while (!nodesToConnect.IsEmpty())
	{
		auto [root, destiny] = FindNextNodeToConnect(connectedNodes, nodesToConnect);
		BuildPipeFromNode(root, destiny);
		connectedNodes.Add(destiny);
		nodesToConnect.Remove(destiny);
	}
}

void UEnergyPipeBuilder::BuildPipeFromNode(UBuildingEnergyNode* from, UBuildingEnergyNode* to)
{
	auto pipe = GetOrCreateUnusedPipe();
	pipe->ConnectRootDestiny(from, to);
}

void UEnergyPipeBuilder::ClearGraphFrom(ABaseEnergyPipe* node)
{
	auto dest = node->GetDestiny();
	node->DisconnectRootDestiny();
	ClearGraphFrom(dest);
}

ABaseEnergyPipe* UEnergyPipeBuilder::GetOrCreateUnusedPipe()
{
	if (unusedPipes.IsEmpty())
	{
		return CreateNewPipe();
	}

	auto pipe = unusedPipes.Last();
	unusedPipes.RemoveAt(unusedPipes.Num() - 1);
	return pipe;
}

ABaseEnergyPipe* UEnergyPipeBuilder::CreateNewPipe()
{
	auto newPipe = GetWorld()->SpawnActor<ABaseEnergyPipe>(pipeType);
	if (!newPipe)
	{
		UE_LOG(LogTemp, Error, TEXT("Could not generate new pipe"));
	}

	pipes.Add(newPipe);

	return newPipe;
}

void UEnergyPipeBuilder::StopUsingPipe(ABaseEnergyPipe* pipe)
{
	pipe->DisconnectRootDestiny();
	unusedPipes.AddUnique(pipe);
}

std::tuple<UBuildingEnergyNode*, float> UEnergyPipeBuilder::FindClosestNodeFrom(UBuildingEnergyNode* node, const TArray<UBuildingEnergyNode*>& candidates)
{
	if (candidates.IsEmpty())return { nullptr, -1.f };

	const FVector nodelocation = node->GetOwner()->GetActorLocation();

	float minDistance = std::numeric_limits<float>::max();
	UBuildingEnergyNode* closestNode = nullptr;

	for (auto& n : candidates)
	{
		const FVector candidateLocation = n->GetOwner()->GetActorLocation();
		const auto dist = static_cast<float>(FVector::DistSquared(nodelocation, candidateLocation));

		if (dist < minDistance)
		{
			minDistance = dist;
			closestNode = n;
		}
	}

	return { closestNode, minDistance };
}




