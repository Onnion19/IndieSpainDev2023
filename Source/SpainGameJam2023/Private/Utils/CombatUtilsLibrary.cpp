// All code generated by Aleix Rius for the Indie Spain Dev 2023. The code is delivered as is.


#include "Utils/CombatUtilsLibrary.h"
#include <algorithm>


float UCombatUtilsLibrary::ResolveCombatStats(const FCombatStats& dealer, const FCombatStats& receiver)
{
	const float flatDamage = dealer.damage * (1.f - dealer.piercingDamagePercent);
	const float piercingDamage = dealer.damage * (dealer.piercingDamagePercent);

	const float damageDealt = std::max(flatDamage - receiver.defense, 0.f) + piercingDamage;

	return damageDealt;
}



void UCombatUtilsLibrary::ResolveCombatStatsByActors(AActor* dealer, AActor* receiver)
{
	if (!dealer || !receiver) return;
	if (!dealer->Implements<UCombatInterface>() || !receiver->Implements<UCombatInterface>())
	{
		UE_LOG(LogTemp, Warning, TEXT("Either Receiver or Dealer does not implement UCombatInterface"));
		return;
	}


	TScriptInterface<ICombatInterface> d{ dealer };
	TScriptInterface<ICombatInterface> r{ receiver };

	const auto damage = ResolveCombatStats(d->Execute_GetCombatStats(dealer), r->Execute_GetCombatStats(receiver));
	UE_LOG(LogTemp, Log, TEXT("Dealing damage to entity"));
	d->Execute_DealDamage(dealer, damage);
	UE_LOG(LogTemp, Log, TEXT("Receiving Damage from eneity"));
	r->Execute_ReceiveDamage(receiver, damage);
}


void UCombatUtilsLibrary::ResolveMultipleCombatStatsByActors(AActor* dealer, TArray<AActor*> receivers)
{
	std::for_each(receivers.begin(), receivers.end(), [&](const auto r) {UCombatUtilsLibrary::ResolveCombatStatsByActors(dealer, r); });
}