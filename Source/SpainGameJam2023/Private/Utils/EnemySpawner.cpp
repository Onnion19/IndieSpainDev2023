// All code generated by Aleix Rius for the Indie Spain Dev 2023. The code is delivered as is.


#include "Utils/EnemySpawner.h"
#include "Math/UnrealMathUtility.h"
#include "Kismet/GameplayStatics.h"
#include "Utils/CombatUtilsLibrary.h"

// Sets default values
AEnemySpawner::AEnemySpawner()
{
	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;

}

// Called when the game starts or when spawned
void AEnemySpawner::BeginPlay()
{
	Super::BeginPlay();

}

// Called every frame
void AEnemySpawner::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

}

void AEnemySpawner::SpawnNewWave(UEnemyDataAsset* data)
{
	currentWave = data;
	OnStartWaveSpawn.Broadcast();
	if (data->waveData.IsEmpty()) return;

	ResetInternalData();
	SpawnSubwave();
}

bool AEnemySpawner::IsSpawning() const
{
	return currentWave && currentSubWave;
}

void AEnemySpawner::ResetInternalData()
{
	auto& timerManager = GetWorldTimerManager();

	StopTimer(spawnHandle);
	StopTimer(delayHandle);

	subwave_currentSubwave = 0;
	subwave_SpawnedEnemies = 0;
	subwave_AccumulatedProbability = 0;
}

void AEnemySpawner::NextSubWave()
{
	if (++subwave_currentSubwave >= currentWave->waveData.Num())
	{
		FinishSpawn();
		return;
	}

	SpawnSubwave();
}

void AEnemySpawner::SpawnSubwave()
{
	currentSubWave = &currentWave->waveData[subwave_currentSubwave];

	for (const auto& [_, prob]: currentSubWave->enemies)
	{
		subwave_AccumulatedProbability += prob;
	}
	StartDelayTimer();
}

void AEnemySpawner::FinishSpawn()
{
	StopTimer(spawnHandle);
	StopTimer(delayHandle);
	currentSubWave = nullptr;
	OnFinishWaveSpawn.Broadcast();

}

void AEnemySpawner::CancelSpawn()
{
	FinishSpawn();
}

void AEnemySpawner::OnDelayTimer()
{
	StopTimer(delayHandle);
	GetWorldTimerManager().SetTimer(spawnHandle, this, &AEnemySpawner::OnSpawnTimer, currentSubWave->spawnRate, true);

}

void AEnemySpawner::OnSpawnTimer()
{
	int32 random = FMath::RandRange(0, subwave_AccumulatedProbability);

	for (const auto& [enemy, prob] : currentSubWave->enemies)
	{
		random -= prob; 
		if (random > 0)continue;

		SpawnEnemy(enemy);
		break;

	}

	if (++subwave_SpawnedEnemies >= currentSubWave->numEnemies)
	{
		StopTimer(spawnHandle);
		NextSubWave();
	}

}

void AEnemySpawner::StopTimer(FTimerHandle& handle)
{
	auto& timerManager = GetWorldTimerManager();
	if (timerManager.IsTimerActive(handle))
		timerManager.ClearTimer(handle);
}

void AEnemySpawner::StartSpawnTimer(float spawnRate)
{
	auto& timerManager = GetWorldTimerManager();
	timerManager.SetTimer(spawnHandle, this, &AEnemySpawner::OnSpawnTimer, spawnRate, true);
}

void AEnemySpawner::StartDelayTimer()
{
	GetWorldTimerManager().SetTimer(delayHandle, this, &AEnemySpawner::OnDelayTimer, currentSubWave->waveDelay + 0.1f, false, currentSubWave->waveDelay + 0.1f);
}

void AEnemySpawner::SpawnEnemy(TSubclassOf<class ABaseEnemy> enemy)
{
	auto world = GetWorld();
	if (!world)return; 

	auto angle = FMath::RandRange(0.f, 360.f);
	auto distance = FMath::RandRange(0.f, range);
	
	
	FVector location = GetActorLocation() + (FVector{ FMath::Cos(angle), FMath::Sin(angle) , 0} * distance);
	
	FActorSpawnParameters params; 
	params.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn;

	FTransform transform{ FRotator{}, location, FVector {1.f} };

	auto newActor = world->SpawnActorDeferred<ABaseEnemy>(enemy, transform);

	ICombatInterface::Execute_SetCombatStats(newActor, ComputeSpawnedCombatStats());
	UGameplayStatics::FinishSpawningActor(newActor, transform);

	OnEnemySpawn.Broadcast(newActor);
}

FCombatStats AEnemySpawner::ComputeSpawnedCombatStats() const
{
	auto level = FMath::RandRange(currentSubWave->minLevel, currentSubWave->maxLevel);
	const FCombatStats baseStats = currentSubWave->combatStats;
	const FCombatStats levelStats = UCombatUtilsLibrary::Multiply(currentSubWave->scalingStats, level);
	return UCombatUtilsLibrary::Add(baseStats, levelStats);
}

